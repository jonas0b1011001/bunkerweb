{% extends "base.html" %}
{% block content %}
<div class="col-span-12 lg:col-span-12 p-4 w-full bg-white dark:bg-slate-850 shadow-md rounded-2xl">
    <h2>Filter by time</h2>
    <div>
        <button class="time-filter active" data-range="24hrs">24 Hours</button>
        <button class="time-filter" data-range="7d">7 Days</button>
        <button class="time-filter" data-range="30d">30 Days</button>
        <button class="time-filter" data-range="max">Max</button>
    </div>
    <div id="update-indicator" class="mt-2 relative">
        <svg width="32" height="32" viewBox="0 0 32 32">
            <circle cx="16" cy="16" r="14" stroke="#4BC0C0" stroke-width="3" fill="none" stroke-dasharray="88" stroke-dashoffset="88"></circle>
        </svg>
        <span id="time-left" class="absolute top-0 left-10">60s</span>
    </div>
</div>

<div class="col-span-12 lg:col-span-12">
    <div id="statistics-content" class="grid grid-cols-12 gap-4"></div>
</div>

<script nonce="{{ script_nonce }}">
    let updateInterval = 60;  // Update-Intervall (in Sekunden)
    let timeLeft = updateInterval;  // Zeit bis zur nächsten Aktualisierung
    let activeRange = '24hrs';  // Standardmäßig 24 Stunden als ausgewählter Filter
    let timer;  // Referenz für das setInterval

    document.querySelectorAll('.time-filter').forEach(button => {
        button.addEventListener('click', function() {
            // Filter-Auswahl visuell hervorheben
            document.querySelectorAll('.time-filter').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            activeRange = this.getAttribute('data-range');

            // Daten sofort neu laden und Timer zurücksetzen
            resetTimer();
            fetchStatistics(activeRange);
        });
    });

    // Initiales Laden der Daten (standardmäßig "max")
    fetchStatistics('max');

    // Datenabruf-Funktion
    function fetchStatistics(range) {
        fetch(`{{ url_for('statistics') }}/data?range=${range}`)
            .then(response => response.json())
            .then(data => renderStatistics(data))
            .catch(error => console.error('Error fetching data:', error));
    }

    // Funktion zur Darstellung der Statistikdaten
    function renderStatistics(data) {
        // Container leeren
        const content = document.getElementById('statistics-content');
        content.innerHTML = '';

        // Dynamisch Daten anzeigen
        content.innerHTML += `
            <div class="col-span-3 lg:col-span-3 p-4 w-full bg-white dark:bg-slate-850 shadow-md rounded-2xl">
                <h4>Total requests</h4>
                <strong>${data.total_requests}</strong>
            </div>
            <div class="col-span-3 lg:col-span-3 p-4 w-full bg-white dark:bg-slate-850 shadow-md rounded-2xl">
                <h4>4xx Error</h4>
                <strong>${data.requests_4xx_percent}%</strong>
            </div>
            <div class="col-span-3 lg:col-span-3 p-4 w-full bg-white dark:bg-slate-850 shadow-md rounded-2xl">
                <h4>5xx Error</h4>
                <strong>${data.requests_5xx_percent}%</strong>
            </div>
            <div class="col-span-3 lg:col-span-3 p-4 w-full bg-white dark:bg-slate-850 shadow-md rounded-2xl">
                <h4>Unique IPs</h4>
                <strong>${data.unique_ips}</strong>
            </div>
        `;

        let _hosts = '<div class="col-span-6 lg:col-span-6 p-4 w-full bg-white dark:bg-slate-850 shadow-md rounded-2xl"><h3>Popular hosts_stats</h3>';
        data.top_hosts.slice(0, 5).forEach(([host, count]) => {
            const percentage = (count / data.total_requests) * 100;
            _hosts += `
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between;">
                            <div style="font-size: 14px;">${host}</div>
                            <div style="font-size: 14px; font-weight: bold;">${count}</div>
                        </div>
                        <div style="background-color: #67748e; border-radius: 5px; height: 10px; position: relative; margin-top: 5px;">
                            <div style="height: 100%; background-color: #f6bf42; border-radius: 5px; width: ${percentage}%;"></div>
                        </div>
                    </div>
            `;
        });
        _hosts += '</div>';
        content.innerHTML += _hosts;

        let _uas = '<div class="col-span-6 lg:col-span-6 p-4 w-full bg-white dark:bg-slate-850 shadow-md rounded-2xl"><h3>Top User Agents</h3>';
        data.top_user_agents.slice(0, 5).forEach(([ua, count]) => {
            const percentage = (count / data.total_requests) * 100;
            _uas += `
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between;">
                            <div style="font-size: 14px;">${ua}</div>
                            <div style="font-size: 14px; font-weight: bold;">${count}</div>
                        </div>
                        <div style="background-color: #67748e; border-radius: 5px; height: 10px; position: relative; margin-top: 5px;">
                            <div style="height: 100%; background-color: #f64279; border-radius: 5px; width: ${percentage}%;"></div>
                        </div>
                    </div>
            `;
        });
        _uas += '</div>';
        content.innerHTML += _uas;
    }

    // Funktion zum Zurücksetzen des Timers
    function resetTimer() {
        clearInterval(timer);  // Aktuellen Timer stoppen
        timeLeft = updateInterval;  // Timer auf Ausgangszeit zurücksetzen
        startTimer();  // Timer erneut starten
    }

    // Timer-Logik
    function startTimer() {
        timer = setInterval(updateTimer, 1000);  // Jede Sekunde aktualisieren
    }

    // Aktualisierungsfunktion und Timer-Logik
    function updateTimer() {
        const circle = document.querySelector('#update-indicator circle');
        const dashArray = 88;  // Voller Umfang des Kreises
        const dashOffset = (timeLeft / updateInterval) * dashArray;
        circle.style.strokeDashoffset = dashOffset;

        // Zeitanzeige aktualisieren
        document.getElementById('time-left').innerText = `${timeLeft}s`;

        timeLeft--;

        if (timeLeft < 0) {
            timeLeft = updateInterval;
            fetchStatistics(activeRange);  // Daten neu laden
        }
    }

    // Starte den Timer nach dem Initialen Laden
    startTimer();
</script>
{% endblock content %}